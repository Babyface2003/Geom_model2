# Geom_model2

Данная лабораторная работа связана с разработкой и отладкой C++ программы, поэтому для ее выполнения требуется компьютер (с минимально разумными требованиями к
быстродействию, объему памяти и т. д.), оборудованный какой-либо средой разработки
C++ приложений (например, Microsoft Visual Studio). Для визуализации создаваемых
геометрических моделей используется OpenGL, для управления окнами приложения
понадобится библиотека GLUT. Для установки рекомендуется версия GLUT под названием freeglut https://sourceforge.net/projects/freeglut/, так как в отличие от
оригинальной библиотеки GLUT проект freeglut поддерживается до настоящего времени.
В принципе, для выполнения лабораторной работы нужно установить freeglut (если
в Вашей системе отсутствует GLUT), следуя инструкциям в соответствующем Вашей
операционной системе файле README (например, README.win32, или README).
Затем собрать отдельный проект из файлов *.h и *.cpp, находящихся в папке code в
материалах для лабораторной. При этом нужно позаботиться о том, чтобы:
• путь к каталогу, где лежит подкаталог GL с включаемыми файлами, был указан
среди мест, где компилятор будет искать включаемые файлы;
• библиотеки OpenGL, а также freeglut, были указаны среди библиотек, которые
линковщик будет подключать к собираемому коду;
• (только для Windows) каталог, содержащий *.dll-файлы библиотек, должен фигурировать в списке каталогов в переменной окружения PATH, либо все необходимые *.dll-файлы должны быть скопированы туда же, где лежит запускаемый
*.exe-файл.
1
Рекомендуемым способом сборки freeglut (а также программы лабораторной работы) является использование CMake http://www.cmake.org. CMake является мультиплатформенной средой сборки и позволяет создавать и конфигурировать проект пригодный для работы в удобной для Вас среде разработки, например, Microsoft Visual
Studio, Qt Creator и др. Ниже описана последовательность действий для установки
freeglut и рабочего проекта лабораторной работы.
1. На странице http://www.cmake.org/download взять актуальную для Вашей системы версию CMake, установить ее (если у Вас на компьютере нет CMake).
2. Если у Вас не установлен GLUT, то взять на странице
https://sourceforge.net/projects/freeglut/ дистрибутив (файл freeglut3.0.0.tar.gz или другой с подобным именем). Распаковать его — должен получиться каталог с именем freeglut-3.0.0 (или похожим, с другим номером версии). Для
распаковки под Linux следует ввести команду tar -xzf freeglut-3.0.0.tar.gz,
а под Windows это можно сделать стандартным распаковщиком 7z или WinRar.
3. Запустить CMake либо командой cmake-gui, либо (для Windows) из системного
меню. Задать каталог исходных файлов (полный путь к извлеченному из архива
freeglut-3.0.0) и каталог сборки (можно задать тот же самый или отдельный пустой каталог). Нажать Configure. Выбрать нужную среду разработки (правильную
версию Visual Studio, Makefile и т. д.) и нажать Finish.
4. Работа с CMake сводится к присваиванию правильных значений управляющим
переменным, появляющимся в основном окне CMake. В данном случае нас интересуют переменные CMAKE_BUILD_TYPE (только в Linux; задать значение Release)
и CMAKE_INSTALL_PREFIX (в Linux оставьте значение по умолчанию, если это Ваш
компьютер и Вы знаете пароль суперпользователя, или задайте Ваш домашний
каталог; для Windows задайте любой подходящий каталог). Нажмите Configure
еще раз, затем Generate.
5. Собственно сборка несколько отличается для разных систем.
(a) Для Linux войдите в каталог сборки (то есть “Where to build the binaries”) и
введите команды
make
su
make install
(естественно, “su” вводите только если Вы знаете пароль суперпользователя). Убедитесь, что переменная окружения PATH содержит подкаталог bin
каталога, который был задан как CMAKE_INSTALL_PREFIX, а переменная окружения LD_LIBRARY_PATH — подкаталог lib оттуда же.
(b) Для Windows нажмите Open Project. В Visual Studio задайте тип сборки
Release, в списке проектов выберите ALL_BUILD (обычно выделен жирным
шрифтом) и соберите его (Build — Build ALL_BUILD). Затем в списке проектов выберите INSTALL и соберите этот проект также. После этого в каталоге,
который был задан как CMAKE_INSTALL_PREFIX, перепишите все файлы библиотек (*.lib) из подкаталога lib, все файлы *.dll из bin и папку GL из include
в сам этот каталог, добавьте путь к этому каталогу в переменную окружения
PATH, и отредактируйте файл GL\freeglut_std.h, добавив в нем перед 45-й
строкой строку
#define FREEGLUT_LIB_PRAGMAS 0
2
6. Установка freeglut закончена. Теперь собираем проект программы лабораторной
работы. Снова запускаем CMake, в качестве каталога исходных текстов (“Where is
the source code”) берем на сей раз путь к папке code из дистрибутива лабораторной
работы. Каталог сборки (“Where to build the binaries”) опять можно выбрать тем
же самым, но лучше (чтобы не смешивать исходные тексты с файлами, образующимися в процессе сборки) выбрать пустой каталог. Нажимаем Configure.
7. Если библиотека freeglut установлена правильно, CMake сам найдет нужные ему
переменные. Если это не произошло, то можно задать вручную правильные значения переменных GLUT_INCLUDE_DIR и GLUT_LIBRARIES. Затем еще раз нажать
Configure, затем Generate и Open Project (для Windows). В среде Visual Studio
нужно выбрать проект GeomModelCurves и сделать его запускаемым по умолчанию (правой кнопкой мыши и выбрать “Set As Startup Project”).
На данном этапе проект должен транслироваться, собираться и запускаться (хотя пока ничего интересного он не рисует). Дальнейшая работа предполагает добавление к проекту новых файлов, их следует добавить в список файлов проекта в файле
CMakeLists.txt (чтобы при повторной сборке эти файлы были доступны).
3 Описание
Все современные CAD-системы имеют в своем составе т. н. геометрическое ядро, т. е.
набор средств для хранения и обработки геометрической формы различных объектов.
Не претендуя на создание полноценного геометрического ядра (это работа большого
коллектива разработчиков в течение длительного времени), в рамках данной работы
мы тем не менее создадим некий прототип геометрического ядра. Несмотря на свою
крайнюю упрощенность, он тем не менее по своей структуре и принципам функционирования будет соответствовать настоящим программным продуктам данного класса.
Наш проект будет состоять из трех относительно независимых частей:
• Собственно геометрическая модель. У нас она будет представлена абстрактным
базовым C++ классом, обеспечивающим интерфейс для работы с параметрической кривой общего вида, и иерархией порожденных классов для конкретных видов сегментов кривых (кривая Безье, B-сплайн и т. д.).
• Графическая система, с помощью которой мы сможем увидеть наши геометрические модели на экране, а в ряде случаев менять параметры геометрических
моделей с помощью движения мыши (интерактивная графика).
• Головная программа. Ее основное назначение — создать конкретную геометрическую модель (то есть объект одного из классов вышеупомянутой иерархии),
запустить графическую систему и обеспечить взаимодействие между ними.
3.1 Геометрическая модель
Для простоты, мы ограничиваем множество представимых геометрических объектов
параметрическими кривыми. Абстрактная параметрическая кривая может быть представлена абстрактным C++ классом, интерфейс которого обеспечивает доступ к параметрическому представлению. Так, кривой
r = r(u), u ∈ [u0, u1]
3
мы сопоставим класс, имеющий следующие функции:
virtual double begin() const; (1)
virtual double end() const; (2)
возвращающие u0 и u1 соответственно, и
virtual vector<2> operator()(double u) const; (3)
возвращающая для заданного u значение r(u)1.
Конкретные виды сегментов кривых (например, кривая Безье) могут быть реализованы порожденными классами, в которых эти функции будут соответствующим
образом переопределены. Каждый класс, естественно, должен содержать внутри себя все данные, необходимые для задания кривой (например, набор опорных точек ri,
i = 0,...,N, для кривой Безье). Тем не менее, остальные части программы (в нашем
случае — графическая система) будут работать с кривыми лишь через интерфейс базового класса, то есть с помощью этих трех функций, ничего не зная о внутреннем
представлении кривой и даже о конкретном виде кривой. (Реализуя тем самым хорошо
известные принципы объектно-ориентированного программирования, такие как инкапсуляция и полиморфизм.)
Таким образом, объект любого класса, порожденного из абстрактного класса кривой, представляет собой модель сегмента кривой. Эта модель может, в принципе, быть
использована в различных вычислениях.
3.2 Графическая система
Графическая система служит для визуализации геометрических моделей. Она должна
работать, с одной стороны, с принятым в данной программной среде представлением
геометрических моделей (т. е. в нашем случае с интерфейсными функциями (1) — (3)),
а с другой стороны, с низкоуровневыми библиотеками поддержки графического оборудования компьютера (в нашем случае это будет связка OpenGL — GLUT). В данной
работе можно использовать готовую графическую систему, представленную в файлах
graphObject.h и graphObject.cpp.
Говоря о графической системе, мы будем рассматривать два важнейшие понятия
(реализованные, естественно, отдельными C++ классами):
• Графическое устройство (класс graphSpace). Это то, на чем рисуются различные
объекты. В терминах Windows это понятие примерно соответствует понятию «контекст отображения», а для простоты графическое устройство может быть отождествлено с отдельным экранным окном. В самом деле, каждый объект класса
graphSpace соответствует своему окну, поэтому создание объекта соответствует появлению окна, а его удаление приводит к удалению окна. Кроме ссылки на
свое (низкоуровневое, в терминах GLUT) окно, объект класса graphSpace должен содержать общие параметры отображения, такие как масштаб (т. е. правило
пересчета физических координат в экранные и наоборот), ракурс (отображение
трехмерного рабочего пространства на плоскость рисунка), количество и расположение источников света и т. д. Для простоты мы ограничимся двумерным рабочим пространством, поэтому параметры отображения в нашем случае сводятся к
1Тип возвращаемого значения vector<2> предназначен для хранения векторных величин и описан
в файле vector.h, распространяемом с материалами лабораторной работы. Не следует его путать с
типом std::vector<class elemtype>.
4
коэффициентам пересчета физических координат в экранные и наоборот. Кроме
этого, графическое устройство должно содержать список всех отображаемых на
нем в данный момент графических объектов и обеспечивать передачу им различных сообщений, приходящих от системы (таких как перерисовка окна из-за его
повторного открытия, нажатие мышкой и т. п.).
• Графический объект (класс graphObject), то есть то, что может быть нарисовано
на графическом устройстве. Каждый графический объект должен уметь себя перерисовывать (т. е. соответствующий класс должен иметь виртуальную функцию,
которая будет вызвана при необходимости перерисовать соответствующее окно),
а также может определенным образом реагировать на нажатие мышкой в области
занимаемой им. Различные типы графических объектов реализуются различными
классами, порожденными из graphObject, однако графическое устройство работает с ними через интерфейс базового класса graphObject, что исключает для
графического устройства необходимость знать подробности реализации всех возможных типов графических объектов.
Для отображения создаваемых нами геометрических объектов (таких, например,
как сегмент параметрической кривой), следует создать соответствующий графический
объект. Для отображения сегментов параметрических кривых используются объекты
класса gCurve<curveType>, где параметр шаблона соответствует классу, реализующему сегмент параметрической кривой. Предполагается, что в этом классе определены
функции (1) — (3), и gCurve<curveType> может их вызывать для перерисовывания
кривой. При создании графического объекта класса gCurve<curveType> необходимо
задать два обязательных параметра — указатель на графическое устройство и указатель на саму кривую2.
Также могут быть графические объекты не связанные с какими-либо геометрическими объектами — например, точки point, используемые нами для обозначения опорных
точек кривой.
На первый взгляд может показаться излишним такое дублирование объектов — каждая кривая представляется геометрическим объектом соответствующего класса с функциями (1) — (3) и графическим объектом. Возникает желание соединить оба класса в
один — например, «зашить» формулы для вычисления r(u) прямо в функцию перерисовки графической кривой. Это плохо по следующим причинам:
• Геометрическая модель в таком случае не существует в чистом, свободном от графических особенностей виде. Между тем она может понадобиться в вычислениях
не связанных с графикой — например, вычислениях точек пересечения кривых.
• Графический объект может содержать индивидуальные параметры отображения — например, кривую можно нарисовать разным цветом, разным стилем
(сплошная, штриховая и т. д.), разной толщины. Эти особенности ни в коей мере
не могут считаться составной частью геометрической модели, поэтому включать
их в класс, описывающий кривую саму по себе, неоправданно.
• Один и тот же геометрический объект теоретически может одновременно отображаться на нескольких графических устройствах3 и с разными параметрами отоб2Третий необязательный параметр задает цвет, которым будет рисоваться кривая, в формате RGB.
Например, vector<3>::comps(1., 0., 0.) задает красный цвет, а vector<3>::comps(0., 0., 1.) —
синий.
3Графическая система graphObject.h — graphObject.cpp простоты ради не поддерживает многооконный режим.
5
ражения — например, в нескольких одновременно открытых окнах в разных ракурсах и разных масштабах. При этом графических объектов будет уже несколько
различных, и они все будут ссылаться на одну и ту же геометрическую модель.
В общем, связь между геометрическим и соответствующим ему графическим объектами
примерно такая же, как между реальным объектом и его изображениями, например,
между человеком и его фотографией.
3.3 Головная программа
В соответствии с требованиями библиотеки GLUT, головная программа (функция
main(int argc, char *argv[])) должна содержать в начале вызов
glutInit(&argc, argv);
для инициализации системы, и
glutMainLoop();
в конце для организации главного цикла (в котором обрабатываются все системные
сообщения). Между этими строками следует поместить определения всех нужных нам
объектов — сначала определить окно:
graphSpace theWindow("Name of window", xMin, xMax, yMin, yMax);
где xMin, xMax, yMin, yMax задают область рабочего пространства, отображаемую
в данном окне. Затем определить нужные геометрические объекты (кривые) и соответствующие им графические объекты.
3.4 Интерактивная графика
В реальных системах часто имеется возможность редактирования введенных объектов,
в частности, изменения управляющих параметров геометрических моделей. Обычно
это связано с появлением большого количества всплывающих окон, в которых задаются новые значения параметров. Мы для простоты реализуем упрощенный подход —
когда опорные точки кривой Безье или B-сплайна можно перемещать мышкой, и такое
перемещение сразу же приводит к соответствующей модификации кривой. Для этого используется графический объект класса gCurveWithPoints<curveType> вместо
gCurve<curveType>, а сама кривая должна допускать возможность модификации известным классу gCurveWithPoints<curveType> способом. Именно, класс curveType
в этом случае должен, помимо функций (1) — (3), иметь также функцию
virtual void resetPoint(int i, const vector<2> &p);
позволяющую задавать новое значение i-й опорной точки.
При создании объекта класса gCurveWithPoints<curveType>, естественно, кроме указателей на графическое устройство aWindow и саму кривую aCurve, долж ны
быть указаны координаты опорных точек. Координаты точек должны быть заданы в
массиве типа std::vector<vector<2> >, и ссылка на этот массив передается как один
из параметров конструктора класса gCurveWithPoints<curveType>:
gCurveWithPoints<curveType> theGraphCurve(&aWindow, points, &aCurve);
6
4 Задание
1. Написать иерархию классов, реализующих основные типы сегментов параметрических кривых — кривую Безье, B-сплайн. Классы должны содержать функциичлены (1) — (3), а также все необходимые средства для задания управляющих
параметров и их изменения. Написать головную программу, задающую какойлибо сегмент кривой и визуализирующую этот сегмент с помощью графической
системы graphObject.h — graphObject.cpp.
2. Написать головную программу, которая будет считывать координаты точек из
файла TurbineBlade.dat или TurbineBladeDetailed.dat4. По этим точкам построить
аппроксимирующую кривую, например, однородный открытый B-сплайн 3 и 4
порядков. Визуализировать аппроксимирующую кривую.
3. Интерактивная графика. Использовав вместо класса gCurve<curveType>
класс gCurveWithPoints<curveType>, построить изображения кривой Безье и
B-сплайна. Исследовать, как меняется форма кривой при перемещениях опорных
точек
